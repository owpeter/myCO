# CPU 设计方案综述

## 总体设计方案概述

![整体设计](image.png)

整体设计参考了黑书

## 数据路径

| 指令  | RegDst | ALUOp[1:0] | AluSrc | RegWr | RegWrOp | MemWr | Beq? | MemToReg | ExtOp |
|:---:|:------:|:----------:|:------:|:-----:|:-------:|:-----:|:----:|:--------:|:-----:|
| ADD | 1      | 00         | 0      | 1     | 0       | 0     | 0    | 0        | x     |
| SUB | 1      | 01         | 0      | 1     | 0       | 0     | 0    | 0        | x     |
| ORI | 0      | 10         | 1      | 1     | 0       | 0     | 0    | 0        | 0     |
| LW  | 0      | 00         | 1      | 1     | 0       | 0     | 0    | 1        | 1     |
| SW  | x      | 00         | 1      | 0     | x       | 1     | 0    | x        | 1     |
| BEQ | x      | 01         | 0      | 0     | x       | 0     | 1    | x        | 1     |
| LUI | 0      | x          | x      | 1     | 1       | 0     | 0    | 0        | 0     |


RegDst: GRF读入的目的地是rs还是rd

ALUSrc: GRF读出的数据还是立即数

# 测试方案

经过对于各种自动测评机的比较之后，我选择了[Shae](https://triplecamera.github.io/co-discussions/1070)的方案，利用学长的代码生成汇编程序后与同学进行对拍。

但有几点需要注意：
* cpu需要支持`jal`指令
* 需要添加计数器与`halt`使程序自动停止

# 思考题

> 上面我们介绍了通过 FSM 理解单周期 CPU 的基本方法。请大家指出单周期 CPU 所用到的模块中，哪些发挥状态存储功能，哪些发挥状态转移功能。

GRF，DM发挥状态存储功能，IFU，ALU，CTRL发挥状态转移功能

> 现在我们的模块中 IM 使用 ROM，DM 使用 RAM，GRF 使用 Register，这种做法合理吗？ 请给出分析，若有改进意见也请一并给出。

一定程度上是合理的。IM在指令加载完成后只需要被读取，因此用ROM是合理的，DM和GRF都有读写的需要，而GRF因为与ALU相连，需要快速读写，因此分别使用RAM和寄存器也是合理的。但在实际生活中，RAM 是易失性存储器，一旦设备断电，存储在其中的数据就会丢失，这就需要额外的措施以防止数据丢失。

> 在上述提示的模块之外，你是否在实际实现时设计了其他的模块？如果是的话，请给出介绍和设计的思路。

多了一个对于GRF写入数据进行选择的模块，主要是为了方便区分I类型指令对于立即数的写入与jal对于PC+4的写入
![alt text](image-1.png)

> 事实上，实现 nop 空指令，我们并不需要将它加入控制信号真值表，为什么？

当CTRL接受到的op和func不能被翻译成任何一个以被实现的指令时，CTRL的所有输出均为默认值0，即不会有任何操作

> 阅读 Pre 的 “MIPS 指令集及汇编语言” 一节中给出的测试样例，评价其强度（可从各个指令的覆盖情况，单一指令各种行为的覆盖情况等方面分析），并指出具体的不足之处。

对于 ori 指令，虽然测试了与 0 或运算和非 0 数之间的或运算，但没有测试边界值情况，如最大和最小的立即数。sw 和 lw 指令没有测试内存地址边界情况，如访问超出内存范围的地址。测试样例是按照特定的顺序和模式编写的，没有进行足够的随机测试。

